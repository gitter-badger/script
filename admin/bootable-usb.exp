#!/usr/bin/env expect
# bootable-usb.exp
# Author: Andy Bettisworth
# Description: Create a bootable USB with your preferred *nix flavour ISO

set timeout -1
set device [lindex $argv 0]
set iso [lindex $argv 1]
set user $env(USER)

proc usage {} {
  send_error "Usage: bootable-usb.exp \[options\] DEVICE ISO\n"
  exit 1
}

proc exit_if_not_file { target } {
  if { ![file exists $target] } {
    send_error "No such file found for $target"
    exit 2
  }
}

proc exit_if_not_device { device } {
  if { [file type $device] != "blockSpecial" } {
    send_error "Missing block device argument"
    exit 3
  }
}

proc exit_if_not_enough_space { mount_point primary_sectors iso } {
  set partition_table [exec sudo fdisk -l /dev/$mount_point]
  regexp {\(logical/physical\):\s(\d*)} $partition_table -> sector_size

  set device_size [expr "$primary_sectors * $sector_size"]
  set iso_size [file size $iso]

  set remainder [expr "$device_size - $iso_size"]
  set r_mb [expr "$remainder / 1024 / 1024"]

  if {$remainder <= 0} {
    send_error "Not enough space on /dev/${mount_point}1 for $iso \nby $r_mb mb\n"
    exit 4
  }
}

proc get_mount_point { device } {
  regexp {\/dev\/(\w*)} $device -> mount_point
  return $mount_point
}

proc get_sector_count { mount_point } {
  set partition_table [exec sudo fdisk -l /dev/$mount_point]
  regexp {total\s(\d*)} $partition_table -> sector_count
  return $sector_count
}

proc get_persistence_percentage {} {
  puts "What percentage should go towards persistence? \[10..40\]"
  expect_user -re "(.*)\n"
  return $expect_out(1,string)
}

proc get_secondary_sectors { sector_count persistence } {
  set sectors [format {%0.0f} [expr $sector_count * ( $persistence / 100.0 )]]
  return $sectors
}

proc get_primary_sectors { sector_count secondary_sectors } {
  set sectors [format {%0.0f} [expr ($sector_count - 1) - $secondary_sectors]]
  return $sectors
}

proc umount_device { user mount_point } {
  set device_tree [exec lsblk]
  set match_tuple [regexp -all -inline "$mount_point\(\\d\)" $device_tree]
  set match_count [expr {[llength $match_tuple] / 2}]

  foreach {group0 group1} $match_tuple {
    if {[catch {exec sudo umount /dev/$group0} fid]} {
      puts "Unmounted partition at /dev/$group0"
    }
  }

  if {[catch {exec sudo umount /media/$user/Village} fid]} {
  }
  if {[catch {exec sudo rm -r /media/$user/Village} fid]} {
  }
  if {[catch {exec sudo umount /media/$user/casper-rw} fid]} {
  }
  if {[catch {exec sudo rm -r /media/$user/casper-rw} fid]} {
  }
}

proc partition_device { mount_point primary_sectors secondary_sectors } {
  spawn sudo fdisk /dev/$mount_point
  expect "?assword*: " {
    expect_user "*\n" { send $expect_out(0,string) }
  }

  if { $secondary_sectors == 0 } {
    send_user "Creating single partition on /dev/$mount_point...\n"

    ## "o\nn\np\n1\n\n\na\n1\nw\n"
    log_user 0
    expect "?ommand*: " { send "o\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "\r" }
    expect "?ommand*: " { send "a\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?ommand*: " { send "w\r" }
    exec sync
    log_user 1

    send_user "Successful partitioning of $mount_point\n"
  } else {
    send_user "Creating partitions on /dev/$mount_point...\n"

    ## "o\nn\np\n1\n\n$primary_sectors\nn\np\n2\n\n\na\n1\nw\n"
    log_user 0
    expect "?ommand*: " { send "o\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "$primary_sectors\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "2\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "\r" }
    expect "?ommand*: " { send "a\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?ommand*: " { send "w\r" }
    exec sync
    log_user 1

    send_user "Successful partitioning of $mount_point\n"
  }
}

proc format_partition { mount_point secondary_sectors } {
  if { $secondary_sectors == 0 } {
    send_user "Formatting /dev/${mount_point}1 NTFS...\n"

    log_user 1
    if {[catch {exec sudo mkntfs -L Village /dev/${mount_point}1} fid]} {
    }
    log_user 0

    exec sync
  } else {
    send_user "Formatting /dev/${mount_point}1 NTFS and /dev/${mount_point}2 ext4...\n"

    log_user 1
    if {[catch {exec sudo mkntfs -L Village /dev/${mount_point}1} fid]} {
    }
    if {[catch {exec sudo mkfs.ext4 -L casper-rw /dev/${mount_point}2} fid]} {
    }
    if {[catch {exec sudo parted -s $mount_point set 1 boot on} fid]} {
    }
    if {[catch {exec sudo parted -s $mount_point set 1 hidden on} fid]} {
    }
    if {[catch {exec sudo parted -s $mount_point set 2 hidden on} fid]} {
    }
    log_user 0

    exec sync
  }
}

proc mount_iso { iso_mount iso } {
  send_user "Mounting ISO $iso...\n"

  if {[catch {exec sudo umount $iso_mount} fid]} {
  }
  if {[catch {exec sudo rm -r $iso_mount} fid]} {
  }

  exec sudo mkdir -p $iso_mount
  exec sudo mount -o ro,loop $iso $iso_mount
}

proc umount_iso { iso_mount iso } {
  send_user "Unmounting ISO $iso...\n"

  if {[catch {exec sudo umount $iso_mount} fid]} {
  }
  if {[catch {exec sudo rm -r $iso_mount} fid]} {
  }
}

proc mount_device { user mount_point secondary_sectors } {
  if { $secondary_sectors == 0 } {
    if {[catch {exec sudo umount /media/$user/Village} fid]} {
    }
    if {[catch {exec sudo rm -r /media/$user/Village} fid]} {
    }

    exec sudo mkdir -p /media/$user/Village
    exec sudo mount /dev/${mount_point}1 /media/$user/Village
  } else {
    if {[catch {exec sudo umount /media/$user/Village} fid]} {
    }
    if {[catch {exec sudo rm -r /media/$user/Village} fid]} {
    }
    if {[catch {exec sudo umount /media/$user/casper-rw} fid]} {
    }
    if {[catch {exec sudo rm -r /media/$user/casper-rw} fid]} {
    }

    exec sudo mkdir -p /media/$user/Village
    exec sudo mkdir -p /media/$user/casper-rw
    exec sudo mount /dev/${mount_point}1 /media/$user/Village
    exec sudo mount /dev/${mount_point}2 /media/$user/casper-rw
  }
}

proc copy_iso_to_device { user mount_point iso } {
  send_user "Extracting ISO files to device...\n"

  log_user 1
  exec rsync -aP "/mnt/tmpiso/" /media/$user/Village
  log_user 0

  exec sudo unlink /media/$user/Village/ubuntu
  exec sudo rm /media/$user/Village/boot/grub/loopback.cfg
}

proc setup_grub_bootloader { user mount_point } {
  if {[catch {exec sudo grub-install --no-floppy --root-directory=/media/$user/Village/ /dev/$mount_point} fid]} {
  }
}

proc build_grub_menu { user secondary_sectors } {
  set menu /media/$user/Village/boot/grub/grub.cfg

  send_user "Enter username: \n"
  expect_user -re "(.*)\n"
  set username $expect_out(1,string)

  send_user "Enter password: \n"
  expect_user -re "(.*)\n"
  set password $expect_out(1,string)
  set pbkdf2_response [exec echo "$password\n$password" | grub-mkpasswd-pbkdf2 --salt=1000]
  regexp {\s(grub\.pbkdf2.*)} $pbkdf2_response -> secret

  set header "set default='guest'\nset timeout=1\nset superusers='$username'\npassword_pbkdf2 $username $secret\nexport superusers\n\n"
  exec echo $header >> $menu

  if { $secondary_sectors != 0 } {
    set menuentry1 "menuentry 'guest' --unrestricted {\n\tlinux /casper/vmlinuz boot=casper priority=low pcspkr.blacklist=yes textonly noprompt persistent --\n\tinitrd /casper/initrd.lz\n}\n"
    exec echo $menuentry1 >> $menu
  }

  set menuentry2 "menuentry 'host' --users '' {\n\tlinux /casper/vmlinuz boot=casper priority=low automatic-ubiquity file=/cdrom/preseed/host.seed live-media-path=/casper/ pcspkr.blacklist=yes textonly noprompt noeject ignore_uuid --\n\tinitrd /casper/initrd.lz\n}\n"
  exec echo $menuentry2 >> $menu
}

proc get_include_install {} {
  puts "Include seed-install?"
  expect_user -re "(.*)\n"
  set answer "n"
  regexp {(y|Y)} $expect_out(1,string) -> answer

  puts $answer

  #if { } {
  #  return 'yes'
  #} else {
  #  return 'no'
  #}
}

proc add_preseed_config { user } {
  set usb_preseed /media/$user/Village/preseed
  set local_preseed /home/$user/.sync/.preseed

  if { [file exists $local_preseed] } {
    exec cp $local_preseed/host.seed $usb_preseed
    exec cp $local_preseed/.seed_config.sh $usb_preseed
    exec cp -r $local_preseed/.seed-config $usb_preseed
  } else {
    send_user "WARNING: no preseed files found locally"
  }
}

#if { [string length $device] != 0 && \
#     [string length $iso] != 0 } {
#  exit_if_not_file $device
#  exit_if_not_device $device
#  exit_if_not_file $iso
#
#  set mount_point [get_mount_point $device]
#  set sector_count [get_sector_count $mount_point]
#  set pct [get_persistence_percentage]
#  set secondary_sectors [get_secondary_sectors $sector_count $pct]
#  set primary_sectors [get_primary_sectors $sector_count $secondary_sectors]
#  exit_if_not_enough_space $mount_point $primary_sectors $iso
#
#  umount_device $user $mount_point
#  partition_device $mount_point $primary_sectors $secondary_sectors
#  format_partition $mount_point $secondary_sectors
#
#  mount_iso /mnt/tmpiso $iso
#  mount_device $user $mount_point $secondary_sectors
#  copy_iso_to_device $user $mount_point $iso
#  umount_iso /mnt/tmpiso $iso
#  setup_grub_bootloader $user $mount_point
#  mount_device $user $mount_point $secondary_sectors
#  build_grub_menu $user $secondary_sectors
#
  get_include_install
#  add_preseed_config $user
#  umount_device $user $mount_point

#  exec sync
#} else {
#  usage
#}