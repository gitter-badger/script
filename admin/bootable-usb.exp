#!/usr/bin/env expect
# bootable-usb.exp
# Author: Andy Bettisworth
# Description: Create a bootable USB any *nix flavour ISO

set timeout -1
set device [lindex $argv 0]
set iso [lindex $argv 1]
set user $env(USER)

proc usage {} {
  send_error "Usage: bootable-usb.exp DEVICE ISO\n"
  exit 1
}

proc exit_if_not_file { target } {
  if { ![file exists $target] } {
    send_error "No file found at $target\n"
    exit 2
  }
}

proc exit_if_not_device { device } {
  if { [file type $device] != "blockSpecial" } {
    send_error "No device found at $device\n"
    exit 3
  }
}

proc exit_if_not_enough_space { mount_point primary_sectors iso } {
  set partition_table [exec sudo fdisk -l /dev/$mount_point]
  regexp {\(logical/physical\):\s(\d*)} $partition_table -> sector_size

  set device_size [expr "$primary_sectors * $sector_size"]
  set iso_size [file size $iso]

  set remainder [expr "$device_size - $iso_size"]
  set r_mb [expr "$remainder / 1024 / 1024"]

  if {$remainder <= 0} {
    send_error "Not enough space on /dev/${mount_point}1 for $iso \nby $r_mb mb\n"
    exit 4
  }
}

proc partition_device { mount_point primary_sectors secondary_sectors } {
  spawn sudo fdisk /dev/$mount_point
  expect "?assword*: " {
    expect_user "*\n" { send $expect_out(0,string) }
  }

  if { $secondary_sectors == 0 } {
    send_user "Creating single partition on /dev/$mount_point...\n"

    ## "o\nn\np\n1\n\n\na\n1\nw\n"
    log_user 0
    expect "?ommand*: " { send "o\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "\r" }
    expect "?ommand*: " { send "a\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?ommand*: " { send "w\r" }
    exec sync
    log_user 1

    send_user "Successful partitioning of $mount_point\n"
  } else {
    send_user "Creating partitions on /dev/$mount_point...\n"

    ## "o\nn\np\n1\n\n$primary_sectors\nn\np\n2\n\n\na\n1\nw\n"
    log_user 0
    expect "?ommand*: " { send "o\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "$primary_sectors\r" }
    expect "?ommand*: " { send "n\r" }
    expect "?elect*: " { send "p\r" }
    expect "?artition number*: " { send "2\r" }
    expect "?irst sector*: " { send "\r" }
    expect "?ast sector*: " { send "\r" }
    expect "?ommand*: " { send "a\r" }
    expect "?artition number*: " { send "1\r" }
    expect "?ommand*: " { send "w\r" }
    exec sync
    log_user 1

    send_user "Successful partitioning of $mount_point\n"
  }
}

proc format_partition { mount_point secondary_sectors } {
  if { $secondary_sectors == 0 } {
    send_user "Formatting /dev/${mount_point}1 NTFS...\n"

    log_user 1
    catch {exec sudo mkntfs -L Village /dev/${mount_point}1}
    log_user 0

    exec sync
  } else {
    send_user "Formatting /dev/${mount_point}1 NTFS and /dev/${mount_point}2 ext4...\n"

    log_user 1
    catch {exec sudo mkntfs -L Village /dev/${mount_point}1}
    catch {exec sudo mkfs.ext4 -L casper-rw /dev/${mount_point}2}
    catch {exec sudo parted -s $mount_point set 1 boot on}
    catch {exec sudo parted -s $mount_point set 1 hidden on}
    catch {exec sudo parted -s $mount_point set 2 hidden on}
    log_user 0

    exec sync
  }
}

proc mount_iso { iso_mount iso } {
  send_user "Mounting ISO $iso...\n"

  catch {exec sudo umount $iso_mount}
  catch {exec sudo rm -r $iso_mount}

  exec sudo mkdir -p $iso_mount
  exec sudo mount -o ro,loop $iso $iso_mount
}

proc umount_iso { iso_mount iso } {
  send_user "Unmounting ISO $iso...\n"

  catch {exec sudo umount $iso_mount}
  catch {exec sudo rm -r $iso_mount}
}

proc mount_device { user mount_point secondary_sectors } {
  if { $secondary_sectors == 0 } {
    catch {exec sudo umount /media/$user/Village}
    catch {exec sudo rm -r /media/$user/Village}

    exec sudo mkdir -p /media/$user/Village
    exec sudo mount /dev/${mount_point}1 /media/$user/Village
  } else {
    catch {exec sudo umount /media/$user/Village}
    catch {exec sudo rm -r /media/$user/Village}
    catch {exec sudo umount /media/$user/casper-rw}
    catch {exec sudo rm -r /media/$user/casper-rw}

    exec sudo mkdir -p /media/$user/Village
    exec sudo mkdir -p /media/$user/casper-rw
    exec sudo mount /dev/${mount_point}1 /media/$user/Village
    exec sudo mount /dev/${mount_point}2 /media/$user/casper-rw
  }
}

proc umount_device { user mount_point } {
  set match_tuple [regexp -all -inline "$mount_point\(\\d\)" [exec lsblk]]
  set match_count [expr {[llength $match_tuple] / 2}]

  foreach {group0 group1} $match_tuple {
    catch {exec sudo umount /dev/$group0}
  }

  catch {exec sudo umount /media/$user/Village}
  catch {exec sudo rm -r /media/$user/Village}
  catch {exec sudo umount /media/$user/casper-rw}
  catch {exec sudo rm -r /media/$user/casper-rw}
}

proc copy_iso_to_device { user mount_point iso } {
  send_user "Extracting ISO files to device...\n"

  log_user 1
  exec rsync -aP "/mnt/tmpiso/" /media/$user/Village
  log_user 0

  exec sudo unlink /media/$user/Village/ubuntu
  exec sudo rm /media/$user/Village/boot/grub/loopback.cfg
}

proc setup_grub_bootloader { user mount_point } {
  catch {exec sudo grub-install --no-floppy --root-directory=/media/$user/Village/ /dev/$mount_point}
}

proc build_grub_menu { user secondary_sectors } {
  set menu /media/$user/Village/boot/grub/grub.cfg

  send_user "Enter username: \n"
  expect_user -re "(.*)\n"
  set username $expect_out(1,string)

  send_user "Enter password: \n"
  expect_user -re "(.*)\n"
  set password $expect_out(1,string)
  set pbkdf2_response [exec echo "$password\n$password" | grub-mkpasswd-pbkdf2 --salt=1000]
  regexp {\s(grub\.pbkdf2.*)} $pbkdf2_response -> secret

  set header "set default='guest'\nset timeout=1\nset superusers='$username'\npassword_pbkdf2 $username $secret\nexport superusers\n\n"
  exec echo $header >> $menu

  if { $secondary_sectors != 0 } {
    set menuentry1 "menuentry 'guest' --unrestricted {\n\tlinux /casper/vmlinuz boot=casper priority=low pcspkr.blacklist=yes textonly noprompt persistent --\n\tinitrd /casper/initrd.lz\n}\n"
    exec echo $menuentry1 >> $menu
  }

  set menuentry2 "menuentry 'host' --users '' {\n\tlinux /casper/vmlinuz boot=casper priority=low automatic-ubiquity file=/cdrom/preseed/host.seed live-media-path=/casper/ pcspkr.blacklist=yes textonly noprompt noeject ignore_uuid --\n\tinitrd /casper/initrd.lz\n}\n"
  exec echo $menuentry2 >> $menu
}

proc get_install_space { user } {
  set local_preseed /home/$user/.sync/.preseed

  regexp {(\d*)} [exec sh -c {df -P /media/raist/Village/ | tail -1 | awk '{print $4}'}] -> device_size
  regexp {(\d*)} [exec du --summarize $local_preseed/.seed-install] -> seed_install_size

  set remainder [expr "$device_size - $seed_install_size"]

  if {$remainder <= 0} {
    return "no"
  } else {
    return "yes"
  }
}

proc get_include_install { enough_install_space } {
  if { $enough_install_space == "yes" } {
    puts "Include seed-install?"
    expect_user -re "(.*)\n"
    set answer "n"
    regexp {(y|Y)} $expect_out(1,string) -> answer

    if { $answer == "y" || $answer == "Y" } {
      return "yes"
    } else {
      return "no"
    }
  } else {
    return "no"
  }
}

proc add_preseed_config { user include_install } {
  set usb_preseed /media/$user/Village/preseed
  set local_preseed /home/$user/.sync/.preseed

  if { [file exists $local_preseed] } {
    exec cp $local_preseed/.seed-config/host.seed $usb_preseed
    exec cp $local_preseed/.seed-config/.seed_config.sh $usb_preseed
    exec cp -r $local_preseed/.seed-config $usb_preseed

    if { $include_install == "yes" } {
      exec cp $local_preseed/.seed-install/.seed_install.sh $usb_preseed
      exec cp -r $local_preseed/.seed-install $usb_preseed
    }
  } else {
    send_user "WARNING: no preseed files found locally\n"
  }
}

if { [string length $device] != 0 && \
     [string length $iso] != 0 } {
  exit_if_not_file $device
  exit_if_not_device $device
  exit_if_not_file $iso

  regexp {\/dev\/(\w*)} $device -> mount_point
  regexp {total\s(\d*)} [exec sudo fdisk -l /dev/$mount_point] -> sector_count

  puts "What percentage should go towards persistence? \[10..40\]"
  expect_user -re "(.*)\n"
  set persistence $expect_out(1,string)

  set secondary_sectors [format {%0.0f} [expr $sector_count * ( $persistence / 100.0 )]]
  set primary_sectors [format {%0.0f} [expr ($sector_count - 1) - $secondary_sectors]]
  exit_if_not_enough_space $mount_point $primary_sectors $iso

  umount_device $user $mount_point
  partition_device $mount_point $primary_sectors $secondary_sectors
  format_partition $mount_point $secondary_sectors

  mount_iso /mnt/tmpiso $iso
  mount_device $user $mount_point $secondary_sectors
  copy_iso_to_device $user $mount_point $iso
  umount_iso /mnt/tmpiso $iso
  setup_grub_bootloader $user $mount_point
  mount_device $user $mount_point $secondary_sectors
  build_grub_menu $user $secondary_sectors

  set enough_install_space [get_install_space $user]
  set include_install [get_include_install $enough_install_space]
  add_preseed_config $user $include_install

  umount_device $user $mount_point
  exec sync
} else {
  usage
}